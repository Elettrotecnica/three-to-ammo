const SHAPE_BOX="box",SHAPE_CYLINDER="cylinder",SHAPE_SPHERE="sphere",SHAPE_CAPSULE="capsule",SHAPE_CONE="cone",SHAPE_HULL="hull",SHAPE_MESH="mesh";class ThreeToAmmo{constructor(){this.vertexPool=[],this.vertices=[],this.matrix=new THREE.Matrix4,this.inverse=new THREE.Matrix4,this.halfExtents=new THREE.Vector3,this.offset=new THREE.Matrix4,this.center=new THREE.Vector3,this.geometries=[],this.boundingBox={min:new THREE.Vector3(Number.MAX_VALUE),max:new THREE.Vector3(Number.MIN_VALUE)},this.pos=new THREE.Vector3,this.quat=new THREE.Quaternion,this.boundingBox=new THREE.Box3}createCollisionShape(a,b){var c=Math.max;const d=b.autoGenerateShape||!0,e=b.shape||SHAPE_HULL,f=b.recenter||!1;b.halfExtents&&this.halfExtents.set(b.halfExtents.x,b.halfExtents.y,b.halfExtents.z);const g=b.cylinderAxis||"y",h=b.sphereRadius||1;let i,k,j,l=this._getMeshes(a);"mesh"!==e&&f&&this._recenter(a,l);let m=this._getVertices(a,l);switch(boundingBox.setFromPoints(m),e){case"box":{let{x:a,y:b,z:c}=this._getHalfExtents(boundingBox),d=new Ammo.btVector3(a,b,c);i=new Ammo.btBoxShape(d),Ammo.destroy(d);break}case"sphere":{let a=1;if(h)a=h;else{let b=new THREE.Sphere;b.setFromPoints(m),isFinite(b.radius)&&(a=b.radius)}i=new Ammo.btSphereShape(a);break}case"cylinder":{let{x:a,y:b,z:c}=this._getHalfExtents(boundingBox),d=new Ammo.btVector3(a,b,c);"y"===g?i=new Ammo.btCylinderShape(d):"x"===g?i=new Ammo.btCylinderShapeX(d):"z"===g?i=new Ammo.btCylinderShapeZ(d):void 0,Ammo.destroy(d);break}case"capsule":{let{x:a,y:b,z:d}=this._getHalfExtents(boundingBox);"y"===g?i=new Ammo.btCapsuleShape(c(a,d),2*b):"x"===g?i=new Ammo.btCapsuleShapeX(c(b,d),2*a):"z"===g?i=new Ammo.btCapsuleShapeZ(c(a,b),2*d):void 0;break}case"cone":{let{x:a,y:b,z:d}=this._getHalfExtents(boundingBox);"y"===g?i=new Ammo.btConeShape(c(a,d),2*b):"x"===g?i=new Ammo.btConeShapeX(c(b,d),2*a):"z"===g?i=new Ammo.btConeShapeZ(c(a,b),2*d):void 0;break}case"hull":{let b=new Ammo.btVector3(a.scale.x,a.scale.y,a.scale.z),c=new Ammo.btVector3,d=new Ammo.btConvexHullShape;d.setMargin(data.margin);for(let a=0;a<m.length;a++)c.setValue(m[a].x,m[a].y,m[a].z),d.addPoint(c,a==m.length-1);i=d,100<=d.getNumVertices()&&(j=new Ammo.btShapeHull(d),j.buildHull(data.margin),Ammo.destroy(d),i=new Ammo.btConvexHullShape(Ammo.getPointer(j.getVertexPointer()),j.numVertices())),i.setLocalScaling(b),Ammo.destroy(b),Ammo.destroy(c);break}case"mesh":{if("static"!==data.type){console.warn("non-static mesh colliders are not currently supported");break}let d=new Ammo.btVector3,a=new Ammo.btVector3,b=new Ammo.btVector3;k=new Ammo.btTriangleMesh(!0,!1);for(let c=0;c<m.length;c+=3)d.setValue(m[c].x,m[c].y,m[c].z),a.setValue(m[c+1].x,m[c+1].y,m[c+1].z),b.setValue(m[c+2].x,m[c+2].y,m[c+2].z),k.addTriangle(d,a,b,c==m.length-3);i=new Ammo.btBvhTriangleMeshShape(k,!0,!0),i.setMargin(data.margin),Ammo.destroy(d),Ammo.destroy(a),Ammo.destroy(b);break}default:return void console.warn(data.shape+" is not currently supported");}return{collisionShape:i,destroy:()=>{j&&Ammo.destroy(j),k&&Ammo.destroy(k),i&&Ammo.destroy(i)}}}_getMeshes(a){let b=[];return a.traverse(a=>{"Mesh"!==a.type||THREE.Sky&&a.__proto__==THREE.Sky.prototype||b.push(a)}),b}_getVertices(a,b){for(;0<this.vertices.length;)this.vertexPool.push(vertices.pop());this.inverse.getInverse(a.matrixWorld);for(let c=0;c<b.length;c++){let a=b[c],d=a.geometry.index?a.geometry.toNonIndexed():a.geometry.clone();if(this.shape===SHAPE_MESH?d.applyMatrix(a.matrixWorld):(this.matrix.multiplyMatrices(this.inverse,a.matrixWorld),d.applyMatrix(this.matrix)),d.isBufferGeometry){let a=d.attributes.position.array;for(let b=0;b<a.length;b+=3){let c=a[b],d=a[b+1],e=a[b+2];0<this.vertexPool.length?this.vertices.push(this.vertexPool.pop().set(c,d,e)):this.vertices.push(new THREE.Vector3(c,d,e))}}else for(let a,b=0;b<d.vertices.length;b++)a=d.vertices[b],0<this.vertexPool.length?this.vertices.push(this.vertexPool.pop().copy(a)):this.vertices.push(new THREE.Vector3(a.x,a.y,a.z))}return vertices}_getHalfExtents(a){if(this.autoGenerateShape){let{min:b,max:c}=a;halfExtents.subVectors(c,b).multiplyScalar(.5)}return{x:this.halfExtents.x,y:this.halfExtents.y,z:this.halfExtents.z}}_recenter(a,b){if(1===b.length)return void b[0].geometry.center();let{min:c,max:d}=this._getBoundingBox(b);this.center.addVectors(d,c).multiplyScalar(-.5),this.offset.makeTranslation(this.center.x,this.center.y,this.center.z);for(let c,d=0;d<b.length;d++)(c=b[d],-1===this.geometries.indexOf(c.geometry.uuid))&&(c.geometry.applyMatrix(this.offset),this.geometries.push(c.geometry.uuid))}_getBoundingBox(a){var b=Math.min,c=Math.max;for(let d,e=0;e<a.length;++e){d=a[e],d.geometry.boundingBox||d.geometry.computeBoundingBox();let f=d.geometry.boundingBox;this.boundingBox.min.x=b(f.min.x,f.min.x),this.boundingBox.min.y=b(f.min.y,f.min.y),this.boundingBox.min.z=b(f.min.z,f.min.z),this.boundingBox.max.x=c(f.max.x,f.max.x),this.boundingBox.max.y=c(f.max.y,f.max.y),this.boundingBox.max.z=c(f.max.z,f.max.z)}return this.boundingBox}}module.exports=ThreeToAmmo;
