const SHAPE_BOX="box",SHAPE_CYLINDER="cylinder",SHAPE_SPHERE="sphere",SHAPE_CAPSULE="capsule",SHAPE_CONE="cone",SHAPE_HULL="hull",SHAPE_MESH="mesh";class ThreeToAmmo{constructor(){this.vertexPool=[],this.vertices=[],this.matrix=new THREE.Matrix4,this.inverse=new THREE.Matrix4,this.halfExtents=new THREE.Vector3,this.offset=new THREE.Matrix4,this.center=new THREE.Vector3,this.geometries=[],this.boundingBox={min:new THREE.Vector3(Number.MAX_VALUE),max:new THREE.Vector3(Number.MIN_VALUE)},this.pos=new THREE.Vector3,this.quat=new THREE.Quaternion,this.boundingBox=new THREE.Box3}createCollisionShape(a,b){var c=Math.max;const d=b.autoGenerateShape||!0,e=b.shape||SHAPE_HULL;this.shape=e;const f=b.recenter||!1;b.halfExtents&&this.halfExtents.set(b.halfExtents.x,b.halfExtents.y,b.halfExtents.z);const g=b.cylinderAxis||"y",h=b.sphereRadius||1,i=b.margin||.01;let j,k,l;const m=this._getMeshes(a);"mesh"!==e&&f&&this._recenter(a,m);const n=this._getVertices(a,m);if(this.boundingBox.setFromPoints(n),d&&-1===["sphere","hull","mesh"].indexOf(e)){const{max:a,min:b}=this.boundingBox;this.halfExtents.subVectors(a,b).multiplyScalar(.5)}const{x:o,y:p,z:q}=this.halfExtents;switch(e){case"box":{const a=new Ammo.btVector3(o,p,q);j=new Ammo.btBoxShape(a),Ammo.destroy(a);break}case"sphere":{let a=1;if(h)a=h;else{const b=new THREE.Sphere;b.setFromPoints(n),isFinite(b.radius)&&(a=b.radius)}j=new Ammo.btSphereShape(a);break}case"cylinder":{const a=new Ammo.btVector3(o,p,q);"y"===g?j=new Ammo.btCylinderShape(a):"x"===g?j=new Ammo.btCylinderShapeX(a):"z"===g?j=new Ammo.btCylinderShapeZ(a):void 0,Ammo.destroy(a);break}case"capsule":{"y"===g?j=new Ammo.btCapsuleShape(c(o,q),2*p):"x"===g?j=new Ammo.btCapsuleShapeX(c(p,q),2*o):"z"===g?j=new Ammo.btCapsuleShapeZ(c(o,p),2*q):void 0;break}case"cone":{"y"===g?j=new Ammo.btConeShape(c(o,q),2*p):"x"===g?j=new Ammo.btConeShapeX(c(p,q),2*o):"z"===g?j=new Ammo.btConeShapeZ(c(o,p),2*q):void 0;break}case"hull":{const b=new Ammo.btVector3(a.scale.x,a.scale.y,a.scale.z),c=new Ammo.btVector3,d=new Ammo.btConvexHullShape;d.setMargin(i);for(let a=0;a<n.length;a++)c.setValue(n[a].x,n[a].y,n[a].z),d.addPoint(c,a==n.length-1);j=d,100<=d.getNumVertices()&&(l=new Ammo.btShapeHull(d),l.buildHull(i),Ammo.destroy(d),j=new Ammo.btConvexHullShape(Ammo.getPointer(l.getVertexPointer()),l.numVertices())),j.setLocalScaling(b),Ammo.destroy(b),Ammo.destroy(c);break}case"mesh":{const d=new Ammo.btVector3,a=new Ammo.btVector3,b=new Ammo.btVector3;k=new Ammo.btTriangleMesh(!0,!1);for(let c=0;c<n.length;c+=3)d.setValue(n[c].x,n[c].y,n[c].z),a.setValue(n[c+1].x,n[c+1].y,n[c+1].z),b.setValue(n[c+2].x,n[c+2].y,n[c+2].z),k.addTriangle(d,a,b,c==n.length-3);j=new Ammo.btBvhTriangleMeshShape(k,!0,!0),j.setMargin(i),Ammo.destroy(d),Ammo.destroy(a),Ammo.destroy(b);break}default:return void console.warn(e+" is not currently supported");}return{collisionShape:j,destroy:()=>{l&&Ammo.destroy(l),k&&Ammo.destroy(k),j&&Ammo.destroy(j)}}}_getMeshes(a){let b=[];return a.traverse(a=>{"Mesh"!==a.type||THREE.Sky&&a.__proto__==THREE.Sky.prototype||b.push(a)}),b}_getVertices(a,b){for(;0<this.vertices.length;)this.vertexPool.push(this.vertices.pop());this.inverse.getInverse(a.matrixWorld);for(let c=0;c<b.length;c++){const a=b[c],d=a.geometry.index?a.geometry.toNonIndexed():a.geometry.clone();if(this.shape===SHAPE_MESH?d.applyMatrix(a.matrixWorld):(this.matrix.multiplyMatrices(this.inverse,a.matrixWorld),d.applyMatrix(this.matrix)),d.isBufferGeometry){const a=d.attributes.position.array;for(let b=0;b<a.length;b+=3){const c=a[b],d=a[b+1],e=a[b+2];0<this.vertexPool.length?this.vertices.push(this.vertexPool.pop().set(c,d,e)):this.vertices.push(new THREE.Vector3(c,d,e))}}else for(let a=0;a<d.vertices.length;a++){const b=d.vertices[a];0<this.vertexPool.length?this.vertices.push(this.vertexPool.pop().copy(b)):this.vertices.push(new THREE.Vector3(b.x,b.y,b.z))}}return this.vertices}_recenter(a,b){if(1===b.length)return void b[0].geometry.center();const{min:c,max:d}=this._getBoundingBox(b);this.center.addVectors(d,c).multiplyScalar(-.5),this.offset.makeTranslation(this.center.x,this.center.y,this.center.z);for(let c=0;c<b.length;c++){const a=b[c];-1===this.geometries.indexOf(a.geometry.uuid)&&(a.geometry.applyMatrix(this.offset),this.geometries.push(a.geometry.uuid))}}_getBoundingBox(a){var b=Math.min,c=Math.max;for(let d=0;d<a.length;++d){const e=a[d];e.geometry.boundingBox||e.geometry.computeBoundingBox();const f=e.geometry.boundingBox;this.boundingBox.min.x=b(f.min.x,f.min.x),this.boundingBox.min.y=b(f.min.y,f.min.y),this.boundingBox.min.z=b(f.min.z,f.min.z),this.boundingBox.max.x=c(f.max.x,f.max.x),this.boundingBox.max.y=c(f.max.y,f.max.y),this.boundingBox.max.z=c(f.max.z,f.max.z)}return this.boundingBox}}module.exports=ThreeToAmmo;
